#!/usr/bin/env bash

# This script is a wrapper for the `notmuch` post-new hook.
# It queries the notmuch database for newly imported messages (those with the 'unread' tag),
# processes them in batches, and applies additional tags based on a classifier.

# Exit immediately if a command exits with a non-zero status.
set -e

# Define the directory where your scripts are located
SCRIPT_DIR=$( dirname $( realpath "${BASH_SOURCE[0]}" ) )
AI_CLASSIFY_SCRIPT="${SCRIPT_DIR}/ai-classify"
GET_MESSAGE_ID_SCRIPT="${SCRIPT_DIR}/get-message-id"
MODEL_PATH="${SCRIPT_DIR}/classify.pkl"

# Set the batch size
BATCH_SIZE=100

# Check for the required 'jq' command
if ! command -v jq &> /dev/null; then
    echo "Error: 'jq' is not installed. Please install it to parse JSON output." >&2
    exit 1
fi

# Function to process a batch of files
process_batch() {
    local batch=("$@")
    # Create an associative array to map filenames back to full paths for the current batch
    declare -A file_map
    local message_ids=()
    
    for full_path in "${batch[@]}"; do
        file_name=$(basename "$full_path")
        file_map["$file_name"]="$full_path"
        message_id=$( $GET_MESSAGE_ID_SCRIPT "$full_path" )
        if [[ -n "$message_id" ]]; then
            message_ids+=("id:$message_id")
        else
            echo "Could not find message ID for file: $full_path"
        fi
    done

    # Call the AI classifier script and process its output
    $AI_CLASSIFY_SCRIPT "${batch[@]}" | while IFS= read -r line; do
        filename_and_tags=($line)
        filename=${filename_and_tags[0]}
        # The remaining elements are the predicted tags
        predicted_tags=("${filename_and_tags[@]:1}")
        full_path="${file_map[$filename]}"
        
        message_id=$( $GET_MESSAGE_ID_SCRIPT "$full_path" );

        if [[ -n "$message_id" ]]; then
            tags_to_add='+$unseen +$tagged'
            for tag in "${predicted_tags[@]}"; do
                tags_to_add+=" +$tag"
            done
            notmuch tag $tags_to_add -- "id:$message_id"
            echo "Applied tags '$tags_to_add' to message ID: $message_id"
        fi
    done
}

echo "Starting mail classification..."

# Initialize a counter for total files and an array for the current batch
total_files=0
batch=()

# Get the list of new mail files and process them in batches
while IFS= read -r full_path; do
    total_files=$((total_files + 1))
    batch+=("$full_path")
    # Process the batch if it reaches the batch size
    if [ ${#batch[@]} -ge $BATCH_SIZE ]; then
        process_batch "${batch[@]}"
        batch=() # Clear the array for the next batch
    fi
done < <(notmuch search --output=files not tag:'$tagged')
# Process any remaining files in the last batch
if [ ${#batch[@]} -gt 0 ]; then
    process_batch "${batch[@]}"
fi

if [ "$total_files" -gt 0 ]; then
    echo "Processing complete. Classified $total_files new messages."
else
    echo "No new messages to classify."
fi
